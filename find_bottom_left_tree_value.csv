userId,problemTitle,language,code,id
698418271da9d8ecc90aa408,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private static int lev;\n    private static int max;\n    public int findBottomLeftValue(TreeNode root) {\n        lev=0;\n        max=root.val;\n        dfs(root,0);\n        return max;\n    }\n    private static void dfs(TreeNode root,int l){\n        if(root.left!=null){\n            if(lev<l+1){\n                lev=l+1;\n                max=root.left.val;\n            }\n            dfs(root.left,l+1);\n        }\n        if(root.right!=null){\n            if(lev<l+1){\n                lev=l+1;\n                max=root.right.val;\n            }\n            dfs(root.right,l+1);\n        }\n    }\n}",88
6984181c1da9d8ecc90aa3d8,Find Bottom Left Tree Value,cpp,"class Solution {\npublic:\n    int maxDepth=-1;\n    int ans=0;\n\n    void dfs(TreeNode* root, int depth) {\n        if(!root) return;\n\n        if(depth>maxDepth) {\n            maxDepth=depth;\n            ans=root->val;\n        }\n\n        dfs(root->left,depth+1);\n        dfs(root->right,depth+1);\n    }\n\n    int findBottomLeftValue(TreeNode* root) {\n        dfs(root,0);\n        return ans;\n    }\n};",89
698418461da9d8ecc90aa4ca,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res=0;\n        Queue<TreeNode> qu=new LinkedList<>();\n        qu.add(root);\n        while(!qu.isEmpty()){\n            int siz=qu.size();\n            boolean vst=false;\n            int val=0;\n            for(int i=0;i<siz;i++){\n                TreeNode cur=qu.poll();\n                if(!vst){\n                    val=cur.val;\n                    vst=true;\n                }\n                if(cur.left!=null) qu.add(cur.left);\n                if(cur.right!=null) qu.add(cur.right);\n            }\n            res=val;\n        }\n        return res;\n    }\n}",91
6984190e1da9d8ecc90aab03,Find Bottom Left Tree Value,python,"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        mp={}\n        queue=collections.deque()\n        queue.append((root,0))\n        while queue:\n            node,idx=queue.popleft()\n            if idx not in mp:\n                mp[idx]=node.val\n            if node.left:\n                queue.append((node.left,idx+1))\n            if node.right:\n                queue.append((node.right,idx+1))\n        lastkey=list(mp.keys())[-1]\n        return mp[lastkey]\n        # return 0",92
698418461da9d8ecc90aa4ca,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res=0;\n        Queue<TreeNode> qu=new LinkedList<>();\n        qu.add(root);\n        while(!qu.isEmpty()){\n            int siz=qu.size();\n            boolean vst=false;\n            int val=0;\n            for(int i=0;i<siz;i++){\n                TreeNode cur=qu.poll();\n                if(!vst){\n                    val=cur.val;\n                    vst=true;\n                }\n                if(cur.left!=null) qu.add(cur.left);\n                if(cur.right!=null) qu.add(cur.right);\n            }\n            res=val;\n        }\n        return res;\n    }\n}",93
698418131da9d8ecc90aa3b8,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int val = -1;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        TreeNode curr;\n        int n;\n        while(!q.isEmpty()){\n            n=q.size();\n            for(int i=0;i<n;i++){\n                curr=q.poll();\n                if(i==0) val=curr.val;\n                if(curr.left!=null) q.add(curr.left);\n                if(curr.right!=null) q.add(curr.right);\n            }\n        }\n        return val;\n    }\n}",95
6984183f1da9d8ecc90aa499,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if (root == null) return 0;\n        int last = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) \n        {\n            int count = queue.size();\n\n            for (int i = 0; i < count; i++) \n            {\n                TreeNode current = queue.poll();\n                if (i == 0) \n                {\n                    last = current.val;\n                }\n                if (current.left != null) \n                {\n                    queue.add(current.left);\n                }\n                if (current.right != null) \n                {\n                    queue.add(current.right);\n                }\n            }\n        }\n        return last;\n    }\n}",96
6984196a1da9d8ecc90aae24,Find Bottom Left Tree Value,python,"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = deque([root])\n        ans = root.val\n        while queue:\n            level_size = len(queue)\n            for i in range(level_size):\n                node = queue.popleft()\n                if i == 0:\n                    ans = node.val\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans",98
6984196a1da9d8ecc90aae24,Find Bottom Left Tree Value,python,"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = deque([root])\n        ans = root.val\n        while queue:\n            level_size = len(queue)\n            for i in range(level_size):\n                node = queue.popleft()\n                if i == 0:\n                    ans = node.val\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans",99
6984196a1da9d8ecc90aae24,Find Bottom Left Tree Value,python,"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = deque([root])\n        ans = root.val\n        while queue:\n            level_size = len(queue)\n            for i in range(level_size):\n                node = queue.popleft()\n                if i == 0:\n                    ans = node.val\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans",100
698418371da9d8ecc90aa47c,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int leftmost=root.val;\n        Queue<TreeNode>que=new LinkedList<>();\n        que.add(root);\n        while(!que.isEmpty()){\n            int qsize=que.size();\n            for(int i=0;i<qsize;i++){\n                TreeNode cur=que.poll();\n                if(i==0)leftmost=cur.val;\n                if(cur.left!=null)que.add(cur.left);\n                if(cur.right!=null)que.add(cur.right);\n            }\n        }\n        return leftmost;\n    }\n}",101
698418821da9d8ecc90aa545,Find Bottom Left Tree Value,java,class Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if (root == null) return 0;\n\n        int last = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            int count = queue.size();\n\n            for (int i = 0; i < count; i++) {\n                TreeNode current = queue.poll();\n                if (i == 0) {\n                    last = current.val;\n                }\n\n                if (current.left != null) {\n                    queue.add(current.left);\n                }\n\n                if (current.right != null) {\n                    queue.add(current.right);\n                }\n            }\n        }\n        return last;\n    }\n},102
698418421da9d8ecc90aa4ad,Find Bottom Left Tree Value,java,"class Solution {\n    private int maxDepth;\n    private int bottomLeftValue;\n    public int findBottomLeftValue(TreeNode root) {\n        maxDepth = -1;\n        bottomLeftValue = 0;\n        dfs(root, 0);\n        return bottomLeftValue;\n    }\n    private void dfs(TreeNode current, int depth) {\n        if (current == null) {\n            return;\n        }\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            bottomLeftValue = current.val;\n        }\n        dfs(current.left, depth + 1);\n        dfs(current.right, depth + 1);\n    }\n}\n",103
6984181a1da9d8ecc90aa3c6,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if(root==null)return 0;\n        int ans=root.val;\n        Queue<TreeNode> que=new LinkedList<>();\n        que.add(root);\n        while(!que.isEmpty()){\n            int size=que.size();\n            for(int i=0;i<size;i++){\n                TreeNode node=que.poll();\n                if(i==0){\n                    ans=node.val;\n                }\n                if(node.left!=null){\n                    que.add(node.left);\n                }\n                if(node.right!=null){\n                    que.add(node.right);\n                }\n            }\n        }\n        return ans;\n        \n    }\n}",104
698418281da9d8ecc90aa416,Find Bottom Left Tree Value,java,"class Solution {\n    static int max,ans;\n    public void find(TreeNode root,int l){\n        if(root==null) return;\n        if(max<l){\n            max=l;\n            ans=root.val;\n        }\n        find(root.left,l+1);\n        find(root.right,l+1);\n    }\n    public int findBottomLeftValue(TreeNode root) {\n        ans=0;max=-1;\n        find(root,0);\n        return ans;\n    }\n}",105
6984183b1da9d8ecc90aa48f,Find Bottom Left Tree Value,java,"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> que = new LinkedList<>();\n        int leftMost = root.val;\n\n        if ( root != null ) que.add(root);\n\n        while ( !que.isEmpty() ){\n            int len = que.size();\n            for ( int i = 0; i < len; i += 1 ){\n                TreeNode top = que.poll();\n                if ( i == 0 ) leftMost = top.val;\n\n                if ( top.left != null ) que.add(top.left);\n                if ( top.right != null ) que.add(top.right);\n            }\n        }\n        \n        return leftMost;\n    }\n}",106
